from pathlib import Path
from typing import List
from models.language_spec import LanguageSpecification


class InterpreterGenerator:
    """Generates interpreter for the language"""

    def __init__(self, spec: LanguageSpecification):
        self.spec = spec

    def generate(self, output_dir: Path) -> List[str]:
        """Generate interpreter files"""
        generated_files = []

        # Generate interpreter
        interpreter_file = output_dir / "interpreter.py"
        with open(interpreter_file, 'w') as f:
            f.write(self._generate_interpreter())
        generated_files.append(str(interpreter_file))

        # Generate environment/symbol table
        env_file = output_dir / "environment.py"
        with open(env_file, 'w') as f:
            f.write(self._generate_environment())
        generated_files.append(str(env_file))

        # Generate runtime builtins
        builtins_file = output_dir / "builtins.py"
        with open(builtins_file, 'w') as f:
            f.write(self._generate_builtins())
        generated_files.append(str(builtins_file))

        # Generate main runner
        main_file = output_dir / f"{self.spec.name.lower()}.py"
        with open(main_file, 'w') as f:
            f.write(self._generate_main())
        generated_files.append(str(main_file))

        return generated_files

    def _generate_interpreter(self) -> str:
        """Generate the interpreter/evaluator"""
        code = '''"""
Interpreter for {name}
Auto-generated by Illiterate Wizard
"""

from typing import Any
from ast_nodes import *
from environment import Environment
from builtins import create_global_environment


class Interpreter:
    def __init__(self):
        self.global_env = create_global_environment()
        self.current_env = self.global_env

    def interpret(self, ast: ProgramNode):
        """Execute the AST"""
        try:
            for statement in ast.statements:
                self.evaluate(statement)
        except Exception as e:
            print(f"Runtime error: {{e}}")
            raise

    def evaluate(self, node: ASTNode) -> Any:
        """Evaluate an AST node"""
        if isinstance(node, ProgramNode):
            result = None
            for statement in node.statements:
                result = self.evaluate(statement)
            return result

        elif isinstance(node, LiteralNode):
            return node.value

        elif isinstance(node, IdentifierNode):
            return self.current_env.get(node.name)

        elif isinstance(node, BinaryOpNode):
            left = self.evaluate(node.left)
            right = self.evaluate(node.right)
            return self._eval_binary_op(node.operator, left, right)

        elif isinstance(node, UnaryOpNode):
            operand = self.evaluate(node.operand)
            return self._eval_unary_op(node.operator, operand)

        elif isinstance(node, AssignmentNode):
            value = self.evaluate(node.value)
            if isinstance(node.target, IdentifierNode):
                self.current_env.set(node.target.name, value)
                return value
            raise RuntimeError(f"Invalid assignment target")

        elif isinstance(node, FunctionCallNode):
            func = self.current_env.get(node.name)
            if not callable(func):
                raise RuntimeError(f"'{{node.name}}' is not a function")
            args = [self.evaluate(arg) for arg in node.arguments]
            return func(*args)

        elif isinstance(node, ExpressionStatementNode):
            return self.evaluate(node.expression)

        elif isinstance(node, BlockNode):
            # Create new scope
            previous_env = self.current_env
            self.current_env = Environment(parent=previous_env)
            try:
                result = None
                for statement in node.statements:
                    result = self.evaluate(statement)
                return result
            finally:
                self.current_env = previous_env

        elif isinstance(node, IfNode):
            condition = self.evaluate(node.condition)
            if self._is_truthy(condition):
                return self.evaluate(node.then_branch)
            elif node.else_branch:
                return self.evaluate(node.else_branch)
            return None

        elif isinstance(node, WhileNode):
            result = None
            while self._is_truthy(self.evaluate(node.condition)):
                result = self.evaluate(node.body)
            return result

        elif isinstance(node, ForNode):
            # Create new scope for loop
            previous_env = self.current_env
            self.current_env = Environment(parent=previous_env)
            try:
                if node.initializer:
                    self.evaluate(node.initializer)

                result = None
                while True:
                    if node.condition and not self._is_truthy(self.evaluate(node.condition)):
                        break
                    result = self.evaluate(node.body)
                    if node.increment:
                        self.evaluate(node.increment)

                return result
            finally:
                self.current_env = previous_env

        elif isinstance(node, FunctionDefNode):
            def func(*args):
                if len(args) != len(node.parameters):
                    raise RuntimeError(f"Expected {{len(node.parameters)}} arguments, got {{len(args)}}")

                # Create new scope for function
                func_env = Environment(parent=self.global_env)
                for param, arg in zip(node.parameters, args):
                    func_env.define(param, arg)

                previous_env = self.current_env
                self.current_env = func_env
                try:
                    self.evaluate(node.body)
                    return None
                except ReturnValue as ret:
                    return ret.value
                finally:
                    self.current_env = previous_env

            self.current_env.define(node.name, func)
            return None

        elif isinstance(node, ReturnNode):
            value = self.evaluate(node.value) if node.value else None
            raise ReturnValue(value)

        elif isinstance(node, VariableDeclarationNode):
            value = self.evaluate(node.initializer) if node.initializer else None
            self.current_env.define(node.name, value)
            return value

        else:
            raise RuntimeError(f"Unknown node type: {{type(node).__name__}}")

    def _eval_binary_op(self, op: str, left: Any, right: Any) -> Any:
        """Evaluate binary operation"""
        {binary_ops}

        raise RuntimeError(f"Unknown operator: {{op}}")

    def _eval_unary_op(self, op: str, operand: Any) -> Any:
        """Evaluate unary operation"""
        if op == '-':
            return -operand
        elif op == '!':
            return not self._is_truthy(operand)
        raise RuntimeError(f"Unknown operator: {{op}}")

    def _is_truthy(self, value: Any) -> bool:
        """Determine truthiness of a value"""
        if value is None or value is False:
            return False
        if value == 0 or value == "":
            return False
        return True


class ReturnValue(Exception):
    """Exception used to implement return statements"""
    def __init__(self, value):
        self.value = value
'''

        # Generate binary operators implementation
        binary_ops = []
        for op in self.spec.operators:
            if op.symbol == '+':
                binary_ops.append("        if op == '+': return left + right")
            elif op.symbol == '-':
                binary_ops.append("        if op == '-': return left - right")
            elif op.symbol == '*':
                binary_ops.append("        if op == '*': return left * right")
            elif op.symbol == '/':
                binary_ops.append("        if op == '/': return left / right")
            elif op.symbol == '%':
                binary_ops.append("        if op == '%': return left % right")
            elif op.symbol == '==':
                binary_ops.append("        if op == '==': return left == right")
            elif op.symbol == '!=':
                binary_ops.append("        if op == '!=': return left != right")
            elif op.symbol == '<':
                binary_ops.append("        if op == '<': return left < right")
            elif op.symbol == '>':
                binary_ops.append("        if op == '>': return left > right")
            elif op.symbol == '<=':
                binary_ops.append("        if op == '<=': return left <= right")
            elif op.symbol == '>=':
                binary_ops.append("        if op == '>=': return left >= right")
            elif op.symbol == '&&':
                binary_ops.append("        if op == '&&': return self._is_truthy(left) and self._is_truthy(right)")
            elif op.symbol == '||':
                binary_ops.append("        if op == '||': return self._is_truthy(left) or self._is_truthy(right)")

        if not binary_ops:
            binary_ops = ["        pass"]

        return code.format(
            name=self.spec.name,
            binary_ops="\n".join(binary_ops)
        )

    def _generate_environment(self) -> str:
        """Generate environment/symbol table"""
        return '''"""
Environment for variable scoping
Auto-generated by Illiterate Wizard
"""

from typing import Any, Dict, Optional


class Environment:
    """Environment for managing variable scopes"""

    def __init__(self, parent: Optional['Environment'] = None):
        self.values: Dict[str, Any] = {}
        self.parent = parent

    def define(self, name: str, value: Any):
        """Define a new variable in this scope"""
        self.values[name] = value

    def get(self, name: str) -> Any:
        """Get a variable value"""
        if name in self.values:
            return self.values[name]
        if self.parent:
            return self.parent.get(name)
        raise NameError(f"Undefined variable: '{name}'")

    def set(self, name: str, value: Any):
        """Set a variable value"""
        if name in self.values:
            self.values[name] = value
            return
        if self.parent:
            self.parent.set(name, value)
            return
        raise NameError(f"Undefined variable: '{name}'")

    def exists(self, name: str) -> bool:
        """Check if a variable exists"""
        if name in self.values:
            return True
        if self.parent:
            return self.parent.exists(name)
        return False
'''

    def _generate_builtins(self) -> str:
        """Generate built-in functions"""
        code = '''"""
Built-in functions for {name}
Auto-generated by Illiterate Wizard
"""

from environment import Environment


def create_global_environment() -> Environment:
    """Create global environment with built-in functions"""
    env = Environment()

    # Standard built-ins
    env.define("print", lambda *args: print(*args))
    env.define("input", lambda prompt="": input(prompt))
    env.define("str", str)
    env.define("int", int)
    env.define("float", float)
    env.define("len", len)

{custom_builtins}

    return env
'''

        # Generate custom built-in functions
        custom_builtins = []
        for func in self.spec.builtin_functions:
            custom_builtins.append(f"    # {func.description}")
            custom_builtins.append(f"    # env.define('{func.name}', {func.name}_impl)")

        return code.format(
            name=self.spec.name,
            custom_builtins="\n".join(custom_builtins) if custom_builtins else "    pass"
        )

    def _generate_main(self) -> str:
        """Generate main runner script"""
        return '''#!/usr/bin/env python3
"""
{name} Language Interpreter
Auto-generated by Illiterate Wizard

Usage: {cmd} <source_file>
"""

import sys
from lexer import Lexer
from parser import Parser
from interpreter import Interpreter


def run_file(filepath: str):
    """Run a {name} source file"""
    try:
        with open(filepath, 'r') as f:
            source = f.read()

        # Lex
        lexer = Lexer(source)
        tokens = lexer.tokenize()

        # Parse
        parser = Parser(tokens)
        ast = parser.parse()

        # Interpret
        interpreter = Interpreter()
        interpreter.interpret(ast)

    except FileNotFoundError:
        print(f"Error: File '{{filepath}}' not found")
        sys.exit(1)
    except SyntaxError as e:
        print(f"Syntax Error: {{e}}")
        sys.exit(1)
    except Exception as e:
        print(f"Error: {{e}}")
        sys.exit(1)


def repl():
    """Run interactive REPL"""
    print("{name} REPL v{version}")
    print("Type 'exit()' to quit")

    interpreter = Interpreter()

    while True:
        try:
            source = input(">>> ")
            if source.strip() in ["exit()", "quit()"]:
                break

            # Lex
            lexer = Lexer(source)
            tokens = lexer.tokenize()

            # Parse
            parser = Parser(tokens)
            ast = parser.parse()

            # Interpret
            interpreter.interpret(ast)

        except (SyntaxError, RuntimeError) as e:
            print(f"Error: {{e}}")
        except (KeyboardInterrupt, EOFError):
            print("\\nGoodbye!")
            break


def main():
    if len(sys.argv) < 2:
        repl()
    else:
        run_file(sys.argv[1])


if __name__ == "__main__":
    main()
'''.format(
            name=self.spec.name,
            version=self.spec.version,
            cmd=f"python {self.spec.name.lower()}.py"
        )
