from pathlib import Path
from typing import List
from models.language_spec import LanguageSpecification


class DocumentationGenerator:
    """Generates documentation for the language"""

    def __init__(self, spec: LanguageSpecification):
        self.spec = spec

    def generate(self, output_dir: Path) -> List[str]:
        """Generate documentation files"""
        generated_files = []

        # Generate main README
        readme_file = output_dir / "README.md"
        with open(readme_file, 'w') as f:
            f.write(self._generate_readme())
        generated_files.append(str(readme_file))

        # Generate language reference
        reference_file = output_dir / "LANGUAGE_REFERENCE.md"
        with open(reference_file, 'w') as f:
            f.write(self._generate_reference())
        generated_files.append(str(reference_file))

        # Generate tutorial
        tutorial_file = output_dir / "TUTORIAL.md"
        with open(tutorial_file, 'w') as f:
            f.write(self._generate_tutorial())
        generated_files.append(str(tutorial_file))

        return generated_files

    def _generate_readme(self) -> str:
        """Generate README.md"""
        impl_type = "interpreter" if self.spec.language_type == "interpreted" else "compiler"
        run_cmd = f"python {self.spec.name.lower()}.py"

        return f'''# {self.spec.name}

{self.spec.description}

**Version:** {self.spec.version}
**Type:** {self.spec.language_type.capitalize()}
**File Extension:** `{self.spec.file_extension}`

## Overview

{self.spec.name} is a general-purpose programming language that is {self.spec.language_type}.
This implementation was generated by **Illiterate Wizard** - a visual programming language builder.

## Installation

No installation required! This is a standalone {impl_type} written in Python.

### Requirements

- Python 3.7 or higher

## Usage

### Running a {self.spec.name} Program

```bash
{run_cmd} program{self.spec.file_extension}
```

### Interactive REPL

```bash
{run_cmd}
```

{"### Compiling" if self.spec.language_type == "compiled" else ""}
{"```bash" if self.spec.language_type == "compiled" else ""}
{run_cmd + " program" + self.spec.file_extension + " -o output.py" if self.spec.language_type == "compiled" else ""}
{"```" if self.spec.language_type == "compiled" else ""}

## Quick Start

### Hello World

See `examples/hello_world{self.spec.file_extension}` for a Hello World example.

### Fibonacci Sequence

See `examples/fibonacci{self.spec.file_extension}` for a Fibonacci sequence example.

## Language Features

### Keywords

{self._format_keywords()}

### Operators

{self._format_operators()}

### Built-in Functions

{self._format_builtins()}

### Data Types

{self._format_datatypes()}

## Documentation

- [Language Reference](LANGUAGE_REFERENCE.md) - Complete language specification
- [Tutorial](TUTORIAL.md) - Step-by-step guide to learning {self.spec.name}

## Examples

Check the `examples/` directory for more code samples.

## License

This language implementation was auto-generated by Illiterate Wizard.

---

*Generated by [Illiterate Wizard](https://github.com/yourusername/illiterate-wizard)*
'''

    def _format_keywords(self) -> str:
        """Format keywords list"""
        if not self.spec.keywords:
            return "No keywords defined."

        lines = []
        for kw in self.spec.keywords:
            lines.append(f"- `{kw.word}` - {kw.description}")
        return "\n".join(lines)

    def _format_operators(self) -> str:
        """Format operators list"""
        if not self.spec.operators:
            return "No operators defined."

        lines = []
        for op in self.spec.operators:
            lines.append(f"- `{op.symbol}` - {op.operation_type} (precedence: {op.precedence}, {op.associativity})")
        return "\n".join(lines)

    def _format_builtins(self) -> str:
        """Format built-in functions"""
        builtins = ["- `print(...)`  - Print values to output",
                    "- `input(prompt)` - Read input from user",
                    "- `str(value)` - Convert to string",
                    "- `int(value)` - Convert to integer",
                    "- `float(value)` - Convert to float"]

        if self.spec.builtin_functions:
            for func in self.spec.builtin_functions:
                params = ", ".join([f"{p['name']}: {p['type']}" for p in func.parameters])
                builtins.append(f"- `{func.name}({params})` - {func.description}")

        return "\n".join(builtins)

    def _format_datatypes(self) -> str:
        """Format data types"""
        if not self.spec.data_types:
            return "- Integer\n- Float\n- String\n- Boolean"

        return "\n".join([f"- {dt.capitalize()}" for dt in self.spec.data_types])

    def _generate_reference(self) -> str:
        """Generate language reference documentation"""
        return f'''# {self.spec.name} Language Reference

This document provides a complete reference for the {self.spec.name} programming language.

## Table of Contents

1. [Lexical Structure](#lexical-structure)
2. [Grammar](#grammar)
3. [Syntax](#syntax)
4. [Semantics](#semantics)
5. [Standard Library](#standard-library)

## Lexical Structure

### Comments

```
Single-line: {self.spec.comment_syntax.get("single_line", "//")}
Multi-line: {self.spec.comment_syntax.get("multi_line_start", "/*")} ... {self.spec.comment_syntax.get("multi_line_end", "*/")}
```

### Keywords

The following words are reserved keywords in {self.spec.name}:

{self._format_keywords()}

### Operators

{self._format_operators()}

### Literals

#### Integer Literals
```
42
1234
0
```

#### Float Literals
```
3.14
0.5
2.0
```

#### String Literals
```
"Hello, World!"
'Single quotes also work'
```

#### Boolean Literals
```
true
false
```

## Grammar

### Grammar Rules

{self._format_grammar_rules()}

### Syntax Rules

{self._format_syntax_rules()}

## Semantics

### Expressions

Expressions are evaluated to produce values. The language supports:

- Arithmetic expressions
- Logical expressions
- Comparison expressions
- Function calls
- Variable references

### Statements

Statements perform actions but do not produce values:

- Expression statements
- Variable declarations
- Control flow statements
- Function definitions

### Type System

{self.spec.name} supports the following types:

{self._format_datatypes()}

## Standard Library

### Built-in Functions

{self._format_builtins()}

## Operator Precedence

Operators are listed from highest to lowest precedence:

{self._format_operator_precedence()}

---

*This reference was auto-generated by Illiterate Wizard*
'''

    def _format_grammar_rules(self) -> str:
        """Format grammar rules"""
        if not self.spec.grammar_rules:
            return "No custom grammar rules defined."

        lines = []
        for rule in self.spec.grammar_rules:
            desc = f" // {rule.description}" if rule.description else ""
            lines.append(f"```\n{rule.name} = {rule.pattern}{desc}\n```\n")
        return "\n".join(lines)

    def _format_syntax_rules(self) -> str:
        """Format syntax rules"""
        if not self.spec.syntax_rules:
            return "No custom syntax rules defined."

        lines = []
        for rule in self.spec.syntax_rules:
            lines.append(f"**{rule.rule_type}:** `{rule.pattern}`  ")
            lines.append(f"Tokens: {', '.join(f'`{t}`' for t in rule.tokens)}  ")
            lines.append(f"Precedence: {rule.precedence}, Associativity: {rule.associativity}\n")
        return "\n".join(lines)

    def _format_operator_precedence(self) -> str:
        """Format operator precedence table"""
        if not self.spec.operators:
            return "No operators defined."

        # Sort by precedence (highest first)
        sorted_ops = sorted(self.spec.operators, key=lambda x: x.precedence, reverse=True)

        lines = []
        current_prec = None
        for op in sorted_ops:
            if op.precedence != current_prec:
                if current_prec is not None:
                    lines.append("")
                lines.append(f"**Precedence {op.precedence}:**")
                current_prec = op.precedence
            lines.append(f"- `{op.symbol}` ({op.associativity})")

        return "\n".join(lines)

    def _generate_tutorial(self) -> str:
        """Generate tutorial documentation"""
        return f'''# {self.spec.name} Tutorial

Welcome to the {self.spec.name} programming language tutorial! This guide will help you get started.

## Lesson 1: Hello, World!

Every programming journey starts with Hello World:

```{self.spec.file_extension[1:]}
print("Hello, World!")
```

Save this in a file called `hello{self.spec.file_extension}` and run it:

```bash
python {self.spec.name.lower()}.py hello{self.spec.file_extension}
```

## Lesson 2: Variables and Data Types

{self.spec.name} supports several data types:

```{self.spec.file_extension[1:]}
x = 42              // Integer
y = 3.14            // Float
name = "Alice"      // String
is_ready = true     // Boolean
```

## Lesson 3: Arithmetic Operations

You can perform calculations:

```{self.spec.file_extension[1:]}
a = 10
b = 5

sum = a + b         // 15
diff = a - b        // 5
product = a * b     // 50
quotient = a / b    // 2
```

## Lesson 4: Control Flow

### If Statements

```{self.spec.file_extension[1:]}
age = 18

if age >= 18 {{
    print("Adult")
}} else {{
    print("Minor")
}}
```

### Loops

**While Loop:**
```{self.spec.file_extension[1:]}
i = 0
while i < 5 {{
    print(i)
    i = i + 1
}}
```

**For Loop:**
```{self.spec.file_extension[1:]}
for i = 0; i < 5; i = i + 1 {{
    print(i)
}}
```

## Lesson 5: Functions

Define reusable code with functions:

```{self.spec.file_extension[1:]}
function greet(name) {{
    print("Hello, " + name + "!")
}}

greet("World")
```

## Lesson 6: Fibonacci Sequence

Let's write a classic program - generating Fibonacci numbers:

```{self.spec.file_extension[1:]}
function fibonacci(n) {{
    if n <= 1 {{
        return n
    }}
    return fibonacci(n - 1) + fibonacci(n - 2)
}}

// Print first 10 Fibonacci numbers
for i = 0; i < 10; i = i + 1 {{
    print(fibonacci(i))
}}
```

## Next Steps

- Explore the [Language Reference](LANGUAGE_REFERENCE.md) for complete details
- Try the examples in the `examples/` directory
- Experiment with the interactive REPL

Happy coding!

---

*This tutorial was auto-generated by Illiterate Wizard*
'''
