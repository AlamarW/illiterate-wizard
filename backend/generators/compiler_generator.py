from pathlib import Path
from typing import List
from models.language_spec import LanguageSpecification


class CompilerGenerator:
    """Generates compiler/transpiler for the language using code generator strategies"""

    def __init__(self, spec: LanguageSpecification):
        self.spec = spec

    def generate(self, output_dir: Path) -> List[str]:
        """Generate compiler files"""
        generated_files = []
        target = self.spec.target_language or "python"

        # Generate code generator module
        codegen_file = output_dir / "codegen.py"
        with open(codegen_file, 'w') as f:
            f.write(self._generate_codegen_module(target))
        generated_files.append(str(codegen_file))

        # Generate compiler main
        compiler_file = output_dir / "compiler.py"
        with open(compiler_file, 'w') as f:
            f.write(self._generate_compiler())
        generated_files.append(str(compiler_file))

        # Generate main runner
        runner_ext = ".py" if target in ["python", "javascript"] else ".py"
        main_file = output_dir / f"{self.spec.name.lower()}{runner_ext}"
        with open(main_file, 'w') as f:
            f.write(self._generate_main())
        generated_files.append(str(main_file))

        # For Java, generate compilation instructions
        if target == "java":
            readme_file = output_dir / "COMPILE.md"
            with open(readme_file, 'w') as f:
                f.write(self._generate_java_compile_instructions())
            generated_files.append(str(readme_file))

        return generated_files

    def _generate_codegen_module(self, target: str) -> str:
        """Generate the codegen.py module with the appropriate generator"""
        if target == "java":
            return self._generate_java_codegen()
        elif target == "javascript":
            return self._generate_javascript_codegen()
        else:  # python
            return self._generate_python_codegen()

    def _generate_python_codegen(self) -> str:
        """Generate Python code generator"""
        return '''"""
Code Generator for {name}
Transpiles to Python
Auto-generated by Illiterate Wizard
"""

from typing import Any
from ast_nodes import *


class CodeGenerator:
    def __init__(self):
        self.indent_level = 0
        self.output = []

    def generate(self, ast: ProgramNode) -> str:
        """Generate Python code from AST"""
        self.output = []
        self.indent_level = 0

        # Add header
        self._emit("#!/usr/bin/env python3")
        self._emit("# Generated by {name} compiler")
        self._emit("")

        # Generate code for each statement
        for statement in ast.statements:
            self._generate_node(statement)

        return "\\n".join(self.output)

    def _emit(self, code: str):
        """Emit a line of code with proper indentation"""
        if code.strip():
            indent = "    " * self.indent_level
            self.output.append(f"{{indent}}{{code}}")
        else:
            self.output.append("")

    def _generate_node(self, node: ASTNode) -> str:
        """Generate code for an AST node"""
        if isinstance(node, ProgramNode):
            for statement in node.statements:
                self._generate_node(statement)
            return ""

        elif isinstance(node, LiteralNode):
            if isinstance(node.value, str):
                return f'"{{node.value}}"'
            elif isinstance(node.value, bool):
                return str(node.value)
            return str(node.value)

        elif isinstance(node, IdentifierNode):
            return node.name

        elif isinstance(node, BinaryOpNode):
            left = self._generate_node(node.left)
            right = self._generate_node(node.right)
            return f"({{left}} {{node.operator}} {{right}})"

        elif isinstance(node, UnaryOpNode):
            operand = self._generate_node(node.operand)
            return f"({{node.operator}}{{operand}})"

        elif isinstance(node, AssignmentNode):
            target = self._generate_node(node.target)
            value = self._generate_node(node.value)
            self._emit(f"{{target}} = {{value}}")
            return ""

        elif isinstance(node, FunctionCallNode):
            args = ", ".join(self._generate_node(arg) for arg in node.arguments)
            return f"{{node.name}}({{args}})"

        elif isinstance(node, ExpressionStatementNode):
            expr = self._generate_node(node.expression)
            if expr:
                self._emit(expr)
            return ""

        elif isinstance(node, BlockNode):
            for statement in node.statements:
                self._generate_node(statement)
            return ""

        elif isinstance(node, IfNode):
            condition = self._generate_node(node.condition)
            self._emit(f"if {{condition}}:")
            self.indent_level += 1
            self._generate_node(node.then_branch)
            self.indent_level -= 1

            if node.else_branch:
                self._emit("else:")
                self.indent_level += 1
                self._generate_node(node.else_branch)
                self.indent_level -= 1
            return ""

        elif isinstance(node, WhileNode):
            condition = self._generate_node(node.condition)
            self._emit(f"while {{condition}}:")
            self.indent_level += 1
            self._generate_node(node.body)
            self.indent_level -= 1
            return ""

        elif isinstance(node, ForNode):
            if node.initializer:
                self._generate_node(node.initializer)

            condition = self._generate_node(node.condition) if node.condition else "True"

            self._emit(f"while {{condition}}:")
            self.indent_level += 1
            self._generate_node(node.body)

            if node.increment:
                self._generate_node(node.increment)

            self.indent_level -= 1
            return ""

        elif isinstance(node, FunctionDefNode):
            params = ", ".join(node.parameters)
            self._emit(f"def {{node.name}}({{params}}):")
            self.indent_level += 1
            self._generate_node(node.body)
            self.indent_level -= 1
            return ""

        elif isinstance(node, ReturnNode):
            if node.value:
                value = self._generate_node(node.value)
                self._emit(f"return {{value}}")
            else:
                self._emit("return")
            return ""

        elif isinstance(node, VariableDeclarationNode):
            if node.initializer:
                value = self._generate_node(node.initializer)
                self._emit(f"{{node.name}} = {{value}}")
            else:
                self._emit(f"{{node.name}} = None")
            return ""

        else:
            raise RuntimeError(f"Unknown node type: {{type(node).__name__}}")
'''.format(name=self.spec.name)

    def _generate_javascript_codegen(self) -> str:
        """Generate JavaScript code generator"""
        # For MVP, JavaScript uses similar structure to Python
        return self._generate_python_codegen().replace("Python", "JavaScript").replace("python", "javascript").replace("#!/usr/bin/env python3", "#!/usr/bin/env node")

    def _generate_java_codegen(self) -> str:
        """Generate Java code generator with type inference"""
        class_name = self.spec.name.replace(" ", "").replace("-", "")

        return '''"""
Code Generator for {name}
Transpiles to Java
Auto-generated by Illiterate Wizard
"""

from typing import Any, Dict
from ast_nodes import *


class CodeGenerator:
    def __init__(self):
        self.indent_level = 0
        self.output = []
        self.class_name = "{class_name}"
        self.variable_types = {{}}  # Track variable types for type inference

    def generate(self, ast: ProgramNode) -> str:
        """Generate Java code from AST"""
        self.output = []
        self.indent_level = 0
        self.variable_types = {{}}

        # Java class header
        self._emit(f"// Generated by {name} compiler")
        self._emit("")
        self._emit(f"public class {{self.class_name}} {{{{")
        self.indent_level += 1

        # Main method
        self._emit("public static void main(String[] args) {{")
        self.indent_level += 1

        # Generate code for each statement
        for statement in ast.statements:
            self._generate_node(statement)

        # Close main method
        self.indent_level -= 1
        self._emit("}}")

        # Close class
        self.indent_level -= 1
        self._emit("}}")

        return "\\n".join(self.output)

    def _emit(self, code: str):
        """Emit a line of code with proper indentation"""
        if code.strip():
            indent = "    " * self.indent_level
            self.output.append(f"{{indent}}{{code}}")
        else:
            self.output.append("")

    def _infer_type(self, node) -> str:
        """Infer Java type from AST node"""
        if isinstance(node, LiteralNode):
            if isinstance(node.value, bool):
                return "boolean"
            elif isinstance(node.value, int):
                return "int"
            elif isinstance(node.value, float):
                return "double"
            elif isinstance(node.value, str):
                return "String"
        elif isinstance(node, BinaryOpNode):
            # Comparison operators return boolean
            if node.operator in ["==", "!=", "<", ">", "<=", ">=", "&&", "||"]:
                return "boolean"

            left_type = self._infer_type(node.left)
            right_type = self._infer_type(node.right)

            # If either operand is double, result is double
            if left_type == "double" or right_type == "double":
                return "double"

            # If either is String and operator is +, result is String
            if (left_type == "String" or right_type == "String") and node.operator == "+":
                return "String"

            return left_type
        elif isinstance(node, UnaryOpNode):
            if node.operator == "!":
                return "boolean"
            return self._infer_type(node.operand)
        elif isinstance(node, IdentifierNode):
            return self.variable_types.get(node.name, "Object")

        return "Object"

    def _generate_node(self, node: ASTNode) -> str:
        """Generate code for an AST node"""
        if isinstance(node, ProgramNode):
            for statement in node.statements:
                self._generate_node(statement)
            return ""

        elif isinstance(node, LiteralNode):
            if isinstance(node.value, str):
                escaped = str(node.value).replace("\\\\", "\\\\\\\\").replace('"', '\\\\"')
                return f'"{{escaped}}"'
            elif isinstance(node.value, bool):
                return "true" if node.value else "false"
            return str(node.value)

        elif isinstance(node, IdentifierNode):
            return node.name

        elif isinstance(node, BinaryOpNode):
            left = self._generate_node(node.left)
            right = self._generate_node(node.right)
            return f"({{left}} {{node.operator}} {{right}})"

        elif isinstance(node, UnaryOpNode):
            operand = self._generate_node(node.operand)
            return f"({{node.operator}}{{operand}})"

        elif isinstance(node, AssignmentNode):
            target = self._generate_node(node.target)
            value = self._generate_node(node.value)

            if isinstance(node.target, IdentifierNode):
                if node.target.name not in self.variable_types:
                    # First assignment - declare with type
                    type_str = self._infer_type(node.value)
                    self.variable_types[node.target.name] = type_str
                    self._emit(f"{{type_str}} {{target}} = {{value}};")
                else:
                    # Already declared
                    self._emit(f"{{target}} = {{value}};")
            else:
                self._emit(f"{{target}} = {{value}};")
            return ""

        elif isinstance(node, FunctionCallNode):
            # Handle built-in functions
            if node.name == "print":
                args = ", ".join(self._generate_node(arg) for arg in node.arguments)
                return f"System.out.println({{args}})"
            else:
                args = ", ".join(self._generate_node(arg) for arg in node.arguments)
                return f"{{node.name}}({{args}})"

        elif isinstance(node, ExpressionStatementNode):
            expr = self._generate_node(node.expression)
            if expr:
                self._emit(f"{{expr}};")
            return ""

        elif isinstance(node, BlockNode):
            for statement in node.statements:
                self._generate_node(statement)
            return ""

        elif isinstance(node, IfNode):
            condition = self._generate_node(node.condition)
            self._emit(f"if ({{condition}}) {{{{")
            self.indent_level += 1
            self._generate_node(node.then_branch)
            self.indent_level -= 1

            if node.else_branch:
                self._emit("}} else {{")
                self.indent_level += 1
                self._generate_node(node.else_branch)
                self.indent_level -= 1
                self._emit("}}")
            else:
                self._emit("}}")
            return ""

        elif isinstance(node, WhileNode):
            condition = self._generate_node(node.condition)
            self._emit(f"while ({{condition}}) {{{{")
            self.indent_level += 1
            self._generate_node(node.body)
            self.indent_level -= 1
            self._emit("}}")
            return ""

        elif isinstance(node, ForNode):
            # Java for loop
            init = ""
            if node.initializer:
                if isinstance(node.initializer, VariableDeclarationNode):
                    type_str = self._infer_type(node.initializer.initializer) if node.initializer.initializer else "int"
                    self.variable_types[node.initializer.name] = type_str
                    value = self._generate_node(node.initializer.initializer) if node.initializer.initializer else "0"
                    init = f"{{type_str}} {{node.initializer.name}} = {{value}}"
                else:
                    init = self._generate_node(node.initializer).rstrip(";")

            condition = self._generate_node(node.condition) if node.condition else "true"
            increment = self._generate_node(node.increment).rstrip(";") if node.increment else ""

            self._emit(f"for ({{init}}; {{condition}}; {{increment}}) {{{{")
            self.indent_level += 1
            self._generate_node(node.body)
            self.indent_level -= 1
            self._emit("}}")
            return ""

        elif isinstance(node, FunctionDefNode):
            # Functions not supported in main method for MVP
            self._emit(f"// Function {{node.name}} not supported in main method (MVP limitation)")
            return ""

        elif isinstance(node, ReturnNode):
            # Return not supported in main for MVP
            self._emit("// return statement not supported in main method (MVP limitation)")
            return ""

        elif isinstance(node, VariableDeclarationNode):
            type_str = self._infer_type(node.initializer) if node.initializer else "Object"
            self.variable_types[node.name] = type_str

            if node.initializer:
                value = self._generate_node(node.initializer)
                self._emit(f"{{type_str}} {{node.name}} = {{value}};")
            else:
                # Java requires initialization
                default_val = {{"int": "0", "double": "0.0", "boolean": "false", "String": '""'}}.get(type_str, "null")
                self._emit(f"{{type_str}} {{node.name}} = {{default_val}};")
            return ""

        else:
            raise RuntimeError(f"Unknown node type: {{type(node).__name__}}")
'''.format(name=self.spec.name, class_name=class_name)

    def _generate_compiler(self) -> str:
        """Generate compiler driver"""
        return '''"""
Compiler for {name}
Auto-generated by Illiterate Wizard
"""

from lexer import Lexer
from parser import Parser
from codegen import CodeGenerator


class Compiler:
    def __init__(self):
        self.codegen = CodeGenerator()

    def compile(self, source: str) -> str:
        """Compile source code to {target}"""
        # Lex
        lexer = Lexer(source)
        tokens = lexer.tokenize()

        # Parse
        parser = Parser(tokens)
        ast = parser.parse()

        # Generate code
        output = self.codegen.generate(ast)

        return output
'''.format(name=self.spec.name, target=self.spec.target_language or "python")

    def _generate_main(self) -> str:
        """Generate main compiler script"""
        target = self.spec.target_language or "python"

        if target == "java":
            target_ext = ".java"
        elif target == "javascript":
            target_ext = ".js"
        else:
            target_ext = ".py"

        class_name = self.spec.name.replace(" ", "").replace("-", "")

        extra_instructions = ""
        if target == "java":
            extra_instructions = f'''
        print("\\nTo compile and run the generated Java code:")
        print(f"  javac {{output_path}}")
        print(f"  java {{output_path.replace('.java', '')}}")
'''

        return '''#!/usr/bin/env python3
"""
{name} Language Compiler
Auto-generated by Illiterate Wizard

Usage: {cmd} <source_file> [-o output_file]
"""

import sys
from pathlib import Path
from compiler import Compiler


def compile_file(source_path: str, output_path: str = None):
    """Compile a {name} source file to {target}"""
    try:
        # Read source
        with open(source_path, 'r') as f:
            source = f.read()

        # Compile
        compiler = Compiler()
        output = compiler.compile(source)

        # Determine output path
        if not output_path:
            source_file = Path(source_path)
            output_path = str(source_file.with_suffix("{target_ext}"))
{extra_naming}

        # Write output
        with open(output_path, 'w') as f:
            f.write(output)

        print(f"Compiled {{source_path}} -> {{output_path}}")
{extra_instructions}

    except FileNotFoundError:
        print(f"Error: File '{{source_path}}' not found")
        sys.exit(1)
    except SyntaxError as e:
        print(f"Syntax Error: {{e}}")
        sys.exit(1)
    except Exception as e:
        print(f"Error: {{e}}")
        sys.exit(1)


def main():
    if len(sys.argv) < 2:
        print("Usage: {cmd} <source_file> [-o output_file]")
        sys.exit(1)

    source_file = sys.argv[1]
    output_file = None

    # Parse arguments
    if len(sys.argv) >= 4 and sys.argv[2] == '-o':
        output_file = sys.argv[3]

    compile_file(source_file, output_file)


if __name__ == "__main__":
    main()
'''.format(
            name=self.spec.name,
            target=target,
            target_ext=target_ext,
            cmd=f"python {self.spec.name.lower()}.py",
            extra_naming=f'''            # For Java, use class name
            if "{target}" == "java":
                output_path = "{class_name}.java"''' if target == "java" else "",
            extra_instructions=extra_instructions
        )

    def _generate_java_compile_instructions(self) -> str:
        """Generate instructions for compiling and running Java output"""
        class_name = self.spec.name.replace(" ", "").replace("-", "")

        return f'''# Compiling and Running {self.spec.name} (Java Target)

This language compiles to Java. Here's how to use the generated Java code:

## Step 1: Compile Your {self.spec.name} Code

```bash
python {self.spec.name.lower()}.py myprogram{self.spec.file_extension}
```

This generates `{class_name}.java`

## Step 2: Compile the Java Code

```bash
javac {class_name}.java
```

This creates `{class_name}.class`

## Step 3: Run the Program

```bash
java {class_name}
```

## Requirements

- Java JDK 8 or higher
- Python 3.7+ (for running the compiler)

## Example Workflow

```bash
# Write your program
echo 'print("Hello from {self.spec.name}!")' > hello{self.spec.file_extension}

# Compile to Java
python {self.spec.name.lower()}.py hello{self.spec.file_extension}

# Compile Java code
javac {class_name}.java

# Run
java {class_name}
```

## Notes

- The generated Java code uses automatic type inference from literals
- Functions are not supported in the MVP (coming in future versions)
- All code runs in the `main` method
'''
