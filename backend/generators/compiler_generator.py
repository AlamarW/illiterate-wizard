from pathlib import Path
from typing import List
from models.language_spec import LanguageSpecification


class CompilerGenerator:
    """Generates compiler/transpiler for the language"""

    def __init__(self, spec: LanguageSpecification):
        self.spec = spec

    def generate(self, output_dir: Path) -> List[str]:
        """Generate compiler files"""
        generated_files = []

        # Generate code generator
        codegen_file = output_dir / "codegen.py"
        with open(codegen_file, 'w') as f:
            f.write(self._generate_codegen())
        generated_files.append(str(codegen_file))

        # Generate compiler main
        compiler_file = output_dir / "compiler.py"
        with open(compiler_file, 'w') as f:
            f.write(self._generate_compiler())
        generated_files.append(str(compiler_file))

        # Generate main runner
        main_file = output_dir / f"{self.spec.name.lower()}.py"
        with open(main_file, 'w') as f:
            f.write(self._generate_main())
        generated_files.append(str(main_file))

        return generated_files

    def _generate_codegen(self) -> str:
        """Generate code generator that transpiles to target language"""
        target = self.spec.target_language or "python"

        code = '''"""
Code Generator for {name}
Transpiles to {target}
Auto-generated by Illiterate Wizard
"""

from typing import Any
from ast_nodes import *


class CodeGenerator:
    def __init__(self):
        self.indent_level = 0
        self.output = []

    def generate(self, ast: ProgramNode) -> str:
        """Generate {target} code from AST"""
        self.output = []
        self.indent_level = 0

        # Add header
        self._emit_header()

        # Generate code for each statement
        for statement in ast.statements:
            self._generate_node(statement)

        return "\\n".join(self.output)

    def _emit(self, code: str):
        """Emit a line of code with proper indentation"""
        indent = "    " * self.indent_level
        self.output.append(f"{{indent}}{{code}}")

    def _emit_header(self):
        """Emit header/imports for generated code"""
        {header_code}

    def _generate_node(self, node: ASTNode) -> str:
        """Generate code for an AST node"""
        if isinstance(node, ProgramNode):
            code_parts = []
            for statement in node.statements:
                code_parts.append(self._generate_node(statement))
            return "\\n".join(code_parts)

        elif isinstance(node, LiteralNode):
            if isinstance(node.value, str):
                return f'"{{node.value}}"'
            return str(node.value)

        elif isinstance(node, IdentifierNode):
            return node.name

        elif isinstance(node, BinaryOpNode):
            left = self._generate_node(node.left)
            right = self._generate_node(node.right)
            return f"({{left}} {{node.operator}} {{right}})"

        elif isinstance(node, UnaryOpNode):
            operand = self._generate_node(node.operand)
            return f"({{node.operator}}{{operand}})"

        elif isinstance(node, AssignmentNode):
            target = self._generate_node(node.target)
            value = self._generate_node(node.value)
            self._emit(f"{{target}} = {{value}}")
            return ""

        elif isinstance(node, FunctionCallNode):
            args = ", ".join(self._generate_node(arg) for arg in node.arguments)
            return f"{{node.name}}({{args}})"

        elif isinstance(node, ExpressionStatementNode):
            expr = self._generate_node(node.expression)
            if expr:
                self._emit(expr)
            return ""

        elif isinstance(node, BlockNode):
            for statement in node.statements:
                self._generate_node(statement)
            return ""

        elif isinstance(node, IfNode):
            condition = self._generate_node(node.condition)
            self._emit(f"if {{condition}}:")
            self.indent_level += 1
            self._generate_node(node.then_branch)
            self.indent_level -= 1

            if node.else_branch:
                self._emit("else:")
                self.indent_level += 1
                self._generate_node(node.else_branch)
                self.indent_level -= 1
            return ""

        elif isinstance(node, WhileNode):
            condition = self._generate_node(node.condition)
            self._emit(f"while {{condition}}:")
            self.indent_level += 1
            self._generate_node(node.body)
            self.indent_level -= 1
            return ""

        elif isinstance(node, ForNode):
            # Convert for loop to while loop for simplicity
            if node.initializer:
                self._generate_node(node.initializer)

            if node.condition:
                condition = self._generate_node(node.condition)
            else:
                condition = "True"

            self._emit(f"while {{condition}}:")
            self.indent_level += 1
            self._generate_node(node.body)

            if node.increment:
                self._generate_node(node.increment)

            self.indent_level -= 1
            return ""

        elif isinstance(node, FunctionDefNode):
            params = ", ".join(node.parameters)
            self._emit(f"def {{node.name}}({{params}}):")
            self.indent_level += 1
            self._generate_node(node.body)
            self.indent_level -= 1
            return ""

        elif isinstance(node, ReturnNode):
            if node.value:
                value = self._generate_node(node.value)
                self._emit(f"return {{value}}")
            else:
                self._emit("return")
            return ""

        elif isinstance(node, VariableDeclarationNode):
            if node.initializer:
                value = self._generate_node(node.initializer)
                self._emit(f"{{node.name}} = {{value}}")
            else:
                self._emit(f"{{node.name}} = None")
            return ""

        else:
            raise RuntimeError(f"Unknown node type: {{type(node).__name__}}")
'''

        # Generate header code based on target language
        if target == "python":
            header_code = '''self._emit("#!/usr/bin/env python3")
        self._emit("# Generated by {name} compiler")
        self._emit("")'''.format(name=self.spec.name)
        elif target == "javascript":
            header_code = '''self._emit("// Generated by {name} compiler")
        self._emit("")'''.format(name=self.spec.name)
        else:
            header_code = f'self._emit("/* Generated by {self.spec.name} compiler */")\n        self._emit("")'

        return code.format(
            name=self.spec.name,
            target=target,
            header_code=header_code
        )

    def _generate_compiler(self) -> str:
        """Generate compiler driver"""
        return '''"""
Compiler for {name}
Auto-generated by Illiterate Wizard
"""

from lexer import Lexer
from parser import Parser
from codegen import CodeGenerator


class Compiler:
    def __init__(self):
        self.codegen = CodeGenerator()

    def compile(self, source: str) -> str:
        """Compile source code to {target}"""
        # Lex
        lexer = Lexer(source)
        tokens = lexer.tokenize()

        # Parse
        parser = Parser(tokens)
        ast = parser.parse()

        # Generate code
        output = self.codegen.generate(ast)

        return output
'''.format(name=self.spec.name, target=self.spec.target_language or "python")

    def _generate_main(self) -> str:
        """Generate main compiler script"""
        target = self.spec.target_language or "python"
        target_ext = ".py" if target == "python" else ".js" if target == "javascript" else ".out"

        return '''#!/usr/bin/env python3
"""
{name} Language Compiler
Auto-generated by Illiterate Wizard

Usage: {cmd} <source_file> [-o output_file]
"""

import sys
from pathlib import Path
from compiler import Compiler


def compile_file(source_path: str, output_path: str = None):
    """Compile a {name} source file to {target}"""
    try:
        # Read source
        with open(source_path, 'r') as f:
            source = f.read()

        # Compile
        compiler = Compiler()
        output = compiler.compile(source)

        # Determine output path
        if not output_path:
            source_file = Path(source_path)
            output_path = source_file.with_suffix("{target_ext}")

        # Write output
        with open(output_path, 'w') as f:
            f.write(output)

        print(f"Compiled {{source_path}} -> {{output_path}}")

    except FileNotFoundError:
        print(f"Error: File '{{source_path}}' not found")
        sys.exit(1)
    except SyntaxError as e:
        print(f"Syntax Error: {{e}}")
        sys.exit(1)
    except Exception as e:
        print(f"Error: {{e}}")
        sys.exit(1)


def main():
    if len(sys.argv) < 2:
        print("Usage: {cmd} <source_file> [-o output_file]")
        sys.exit(1)

    source_file = sys.argv[1]
    output_file = None

    # Parse arguments
    if len(sys.argv) >= 4 and sys.argv[2] == '-o':
        output_file = sys.argv[3]

    compile_file(source_file, output_file)


if __name__ == "__main__":
    main()
'''.format(
            name=self.spec.name,
            target=target,
            target_ext=target_ext,
            cmd=f"python {self.spec.name.lower()}.py"
        )
