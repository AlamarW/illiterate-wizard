"""
Base code generator and strategy pattern implementation
"""
from abc import ABC, abstractmethod
from typing import Any, Dict
from ast_nodes import *


class CodeGenerator(ABC):
    """Abstract base class for code generators"""

    def __init__(self, language_name: str, spec_data: Dict[str, Any]):
        self.language_name = language_name
        self.spec = spec_data
        self.indent_level = 0
        self.output = []

    def generate(self, ast) -> str:
        """Generate code from AST"""
        self.output = []
        self.indent_level = 0

        # Add header/imports
        self._emit_header()

        # Generate code for each statement
        for statement in ast.statements:
            self._generate_node(statement)

        # Add footer if needed
        self._emit_footer()

        return "\n".join(self.output)

    def _emit(self, code: str):
        """Emit a line of code with proper indentation"""
        if code.strip():  # Only indent non-empty lines
            indent = self._get_indent()
            self.output.append(f"{indent}{code}")
        else:
            self.output.append("")

    def _get_indent(self) -> str:
        """Get indentation string"""
        return self._indent_char() * self.indent_level

    @abstractmethod
    def _indent_char(self) -> str:
        """Return the indentation character(s)"""
        pass

    @abstractmethod
    def _emit_header(self):
        """Emit header/imports"""
        pass

    def _emit_footer(self):
        """Emit footer (optional, can be overridden)"""
        pass

    @abstractmethod
    def _generate_node(self, node) -> str:
        """Generate code for an AST node"""
        pass

    @abstractmethod
    def _infer_type(self, node) -> str:
        """Infer the type of a node"""
        pass


class PythonCodeGenerator(CodeGenerator):
    """Python code generator"""

    def _indent_char(self) -> str:
        return "    "

    def _emit_header(self):
        self._emit("#!/usr/bin/env python3")
        self._emit(f"# Generated by {self.language_name} compiler")
        self._emit("")

    def _infer_type(self, node) -> str:
        """Python is dynamically typed, so this is not used"""
        return "any"

    def _generate_node(self, node) -> str:
        """Generate Python code for an AST node"""
        if isinstance(node, ProgramNode):
            code_parts = []
            for statement in node.statements:
                code_parts.append(self._generate_node(statement))
            return "\n".join(code_parts)

        elif isinstance(node, LiteralNode):
            if isinstance(node.value, str):
                return f'"{node.value}"'
            elif isinstance(node.value, bool):
                return str(node.value)
            return str(node.value)

        elif isinstance(node, IdentifierNode):
            return node.name

        elif isinstance(node, BinaryOpNode):
            left = self._generate_node(node.left)
            right = self._generate_node(node.right)
            return f"({left} {node.operator} {right})"

        elif isinstance(node, UnaryOpNode):
            operand = self._generate_node(node.operand)
            return f"({node.operator}{operand})"

        elif isinstance(node, AssignmentNode):
            target = self._generate_node(node.target)
            value = self._generate_node(node.value)
            self._emit(f"{target} = {value}")
            return ""

        elif isinstance(node, FunctionCallNode):
            args = ", ".join(self._generate_node(arg) for arg in node.arguments)
            return f"{node.name}({args})"

        elif isinstance(node, ExpressionStatementNode):
            expr = self._generate_node(node.expression)
            if expr:
                self._emit(expr)
            return ""

        elif isinstance(node, BlockNode):
            for statement in node.statements:
                self._generate_node(statement)
            return ""

        elif isinstance(node, IfNode):
            condition = self._generate_node(node.condition)
            self._emit(f"if {condition}:")
            self.indent_level += 1
            self._generate_node(node.then_branch)
            self.indent_level -= 1

            if node.else_branch:
                self._emit("else:")
                self.indent_level += 1
                self._generate_node(node.else_branch)
                self.indent_level -= 1
            return ""

        elif isinstance(node, WhileNode):
            condition = self._generate_node(node.condition)
            self._emit(f"while {condition}:")
            self.indent_level += 1
            self._generate_node(node.body)
            self.indent_level -= 1
            return ""

        elif isinstance(node, ForNode):
            # Convert for loop to while loop for simplicity
            if node.initializer:
                self._generate_node(node.initializer)

            if node.condition:
                condition = self._generate_node(node.condition)
            else:
                condition = "True"

            self._emit(f"while {condition}:")
            self.indent_level += 1
            self._generate_node(node.body)

            if node.increment:
                self._generate_node(node.increment)

            self.indent_level -= 1
            return ""

        elif isinstance(node, FunctionDefNode):
            params = ", ".join(node.parameters)
            self._emit(f"def {node.name}({params}):")
            self.indent_level += 1
            self._generate_node(node.body)
            self.indent_level -= 1
            return ""

        elif isinstance(node, ReturnNode):
            if node.value:
                value = self._generate_node(node.value)
                self._emit(f"return {value}")
            else:
                self._emit("return")
            return ""

        elif isinstance(node, VariableDeclarationNode):
            if node.initializer:
                value = self._generate_node(node.initializer)
                self._emit(f"{node.name} = {value}")
            else:
                self._emit(f"{node.name} = None")
            return ""

        else:
            raise RuntimeError(f"Unknown node type: {type(node).__name__}")


class JavaCodeGenerator(CodeGenerator):
    """Java code generator with type inference"""

    def __init__(self, language_name: str, spec_data: Dict[str, Any]):
        super().__init__(language_name, spec_data)
        self.class_name = language_name.replace(" ", "").replace("-", "")
        self.variable_types: Dict[str, str] = {}  # Track variable types
        self.in_main = False

    def _indent_char(self) -> str:
        return "    "

    def _emit_header(self):
        self._emit(f"// Generated by {self.language_name} compiler")
        self._emit("")
        self._emit(f"public class {self.class_name} {{")
        self.indent_level += 1
        self._emit("public static void main(String[] args) {")
        self.indent_level += 1
        self.in_main = True

    def _emit_footer(self):
        if self.in_main:
            self.indent_level -= 1
            self._emit("}")
        self.indent_level -= 1
        self._emit("}")

    def _infer_type(self, node) -> str:
        """Infer Java type from AST node"""
        if isinstance(node, LiteralNode):
            if isinstance(node.value, bool):
                return "boolean"
            elif isinstance(node.value, int):
                return "int"
            elif isinstance(node.value, float):
                return "double"
            elif isinstance(node.value, str):
                return "String"
        elif isinstance(node, BinaryOpNode):
            # Infer from operands
            left_type = self._infer_type(node.left)
            right_type = self._infer_type(node.right)

            # Comparison operators return boolean
            if node.operator in ["==", "!=", "<", ">", "<=", ">=", "&&", "||"]:
                return "boolean"

            # If either operand is double, result is double
            if left_type == "double" or right_type == "double":
                return "double"

            # If either is String and operator is +, result is String
            if (left_type == "String" or right_type == "String") and node.operator == "+":
                return "String"

            return left_type
        elif isinstance(node, UnaryOpNode):
            if node.operator == "!":
                return "boolean"
            return self._infer_type(node.operand)
        elif isinstance(node, IdentifierNode):
            # Look up in symbol table
            return self.variable_types.get(node.name, "Object")
        elif isinstance(node, FunctionCallNode):
            # Built-in functions
            if node.name == "print":
                return "void"
            return "Object"

        return "Object"  # Default

    def _generate_node(self, node) -> str:
        """Generate Java code for an AST node"""
        if isinstance(node, ProgramNode):
            for statement in node.statements:
                self._generate_node(statement)
            return ""

        elif isinstance(node, LiteralNode):
            if isinstance(node.value, str):
                # Escape special characters
                escaped = node.value.replace("\\", "\\\\").replace('"', '\\"')
                return f'"{escaped}"'
            elif isinstance(node.value, bool):
                return "true" if node.value else "false"
            elif isinstance(node.value, float):
                return f"{node.value}"
            return str(node.value)

        elif isinstance(node, IdentifierNode):
            return node.name

        elif isinstance(node, BinaryOpNode):
            left = self._generate_node(node.left)
            right = self._generate_node(node.right)

            # Map operators
            op = node.operator
            if op == "&&":
                op = "&&"
            elif op == "||":
                op = "||"
            elif op == "!":
                op = "!"

            return f"({left} {op} {right})"

        elif isinstance(node, UnaryOpNode):
            operand = self._generate_node(node.operand)
            return f"({node.operator}{operand})"

        elif isinstance(node, AssignmentNode):
            target = self._generate_node(node.target)
            value = self._generate_node(node.value)

            # Check if variable exists
            if isinstance(node.target, IdentifierNode):
                if node.target.name not in self.variable_types:
                    # First assignment - declare with type
                    type_str = self._infer_type(node.value)
                    self.variable_types[node.target.name] = type_str
                    self._emit(f"{type_str} {target} = {value};")
                else:
                    # Already declared
                    self._emit(f"{target} = {value};")
            else:
                self._emit(f"{target} = {value};")
            return ""

        elif isinstance(node, FunctionCallNode):
            # Handle built-in functions
            if node.name == "print":
                args = ", ".join(self._generate_node(arg) for arg in node.arguments)
                return f"System.out.println({args})"
            else:
                args = ", ".join(self._generate_node(arg) for arg in node.arguments)
                return f"{node.name}({args})"

        elif isinstance(node, ExpressionStatementNode):
            expr = self._generate_node(node.expression)
            if expr:
                self._emit(f"{expr};")
            return ""

        elif isinstance(node, BlockNode):
            for statement in node.statements:
                self._generate_node(statement)
            return ""

        elif isinstance(node, IfNode):
            condition = self._generate_node(node.condition)
            self._emit(f"if ({condition}) {{")
            self.indent_level += 1
            self._generate_node(node.then_branch)
            self.indent_level -= 1

            if node.else_branch:
                self._emit("} else {")
                self.indent_level += 1
                self._generate_node(node.else_branch)
                self.indent_level -= 1
                self._emit("}")
            else:
                self._emit("}")
            return ""

        elif isinstance(node, WhileNode):
            condition = self._generate_node(node.condition)
            self._emit(f"while ({condition}) {{")
            self.indent_level += 1
            self._generate_node(node.body)
            self.indent_level -= 1
            self._emit("}")
            return ""

        elif isinstance(node, ForNode):
            # Java for loop
            init = ""
            if node.initializer:
                # Need to handle initialization specially
                if isinstance(node.initializer, VariableDeclarationNode):
                    type_str = self._infer_type(node.initializer.initializer) if node.initializer.initializer else "int"
                    self.variable_types[node.initializer.name] = type_str
                    value = self._generate_node(node.initializer.initializer) if node.initializer.initializer else "0"
                    init = f"{type_str} {node.initializer.name} = {value}"
                else:
                    init = self._generate_node(node.initializer).rstrip(";")

            condition = self._generate_node(node.condition) if node.condition else "true"
            increment = self._generate_node(node.increment).rstrip(";") if node.increment else ""

            self._emit(f"for ({init}; {condition}; {increment}) {{")
            self.indent_level += 1
            self._generate_node(node.body)
            self.indent_level -= 1
            self._emit("}")
            return ""

        elif isinstance(node, FunctionDefNode):
            # Java methods (outside main - not supported in MVP, but placeholder)
            # For MVP, functions inside main aren't allowed in Java
            # We'll just skip for now or emit a comment
            self._emit(f"// Function {node.name} not supported in main method")
            return ""

        elif isinstance(node, ReturnNode):
            # Not supported in main method for MVP
            self._emit("// return statement not supported in main method")
            return ""

        elif isinstance(node, VariableDeclarationNode):
            type_str = self._infer_type(node.initializer) if node.initializer else "Object"
            self.variable_types[node.name] = type_str

            if node.initializer:
                value = self._generate_node(node.initializer)
                self._emit(f"{type_str} {node.name} = {value};")
            else:
                # Java requires initialization
                default_val = self._get_default_value(type_str)
                self._emit(f"{type_str} {node.name} = {default_val};")
            return ""

        else:
            raise RuntimeError(f"Unknown node type: {type(node).__name__}")

    def _get_default_value(self, type_str: str) -> str:
        """Get default value for a Java type"""
        defaults = {
            "int": "0",
            "double": "0.0",
            "boolean": "false",
            "String": '""',
        }
        return defaults.get(type_str, "null")


class JavaScriptCodeGenerator(CodeGenerator):
    """JavaScript code generator"""

    def _indent_char(self) -> str:
        return "    "

    def _emit_header(self):
        self._emit(f"// Generated by {self.language_name} compiler")
        self._emit("")

    def _infer_type(self, node) -> str:
        """JavaScript is dynamically typed, so this is not used"""
        return "any"

    def _generate_node(self, node) -> str:
        """Generate JavaScript code - similar to Python but with JS syntax"""
        # Implementation similar to PythonCodeGenerator but with JS syntax
        # For now, we can reuse Python logic with minor tweaks
        # This is a simplified version
        python_gen = PythonCodeGenerator(self.language_name, self.spec)
        python_gen.output = self.output
        python_gen.indent_level = self.indent_level
        result = python_gen._generate_node(node)
        self.output = python_gen.output
        self.indent_level = python_gen.indent_level
        return result
